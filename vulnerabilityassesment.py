from flask import Flask, request, jsonify
import joblib
import numpy as np
import json

app = Flask(__name__)

# Load the pre-trained model (replace with your model file)
# model = joblib.load('smart_contract_model.pkl')  # Adjust path as necessary

@app.route('/analyze', methods=['POST'])
def analyze_contract():
    # Get the JSON data from the request
    data = request.get_json()
    
    # Validate incoming data
    if not data or 'source_code' not in data or 'contract_name' not in data:
        return jsonify({"error": "Invalid input data"}), 400

    # Extract the necessary data
    contract_name = data['contract_name']
    source_code = data['source_code']
    analysis_tools = data.get('analysis_tools', {})
    
    # Perform vulnerability analysis (mocked response for demonstration)
    findings = []
    
    # Here you would typically call Mythril and Slither to perform the analysis
    if 'mythril' in analysis_tools and analysis_tools['mythril']:
        findings.append({
            "cwe": "CWE-190",
            "description": "Integer overflow/underflow vulnerability detected.",
            "mitre": "T1518",
            "suggestion": "Use SafeMath library to prevent overflows and underflows.",
            "vulnerability": "integer_overflow"
        })
    
    if 'slither' in analysis_tools and analysis_tools['slither']:
        findings.append({
            "cwe": "CWE-839",
            "description": "Unchecked low-level call.",
            "mitre": "T1519",
            "suggestion": "Use require to check return value of low-level calls.",
            "vulnerability": "unchecked_low_level_call"
        })

    # Return the findings as a JSON response
    return jsonify({"findings": findings}), 200

@app.route('/predict', methods=['GET'])
def get_openzeppelin_contracts():
    # This endpoint could return information or example contracts from OpenZeppelin
    openzeppelin_contracts = [
        {
            "name": "ERC20",
            "description": "Standard interface for ERC20 tokens.",
            "link": "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol"
        },
        {
            "name": "Ownable",
            "description": "Basic contract for ownership management.",
            "link": "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol"
        }
        # Add more contracts as needed
    ]
    return jsonify(openzeppelin_contracts)

def extract_features_from_findings(findings):
    # Initialize feature list
    features = []
    
    # Example of extracting features based on findings
    # Let's assume findings is a dictionary containing vulnerabilities and other relevant information
    if isinstance(findings, dict):
        vulnerabilities = findings.get("findings", [])
        feature_count = len(vulnerabilities)  # Total number of vulnerabilities found

        # Initialize feature values
        integer_overflow = 0
        unchecked_low_level_calls = 0
        warnings_count = 0

        for finding in vulnerabilities:
            if finding.get("vulnerability") == "integer_overflow":
                integer_overflow += 1
            if "low-level calls" in finding.get("description", "").lower():
                unchecked_low_level_calls += 1
            
            # Increment warnings count for any type of warning found
            if "Warning" in finding.get("description", ""):
                warnings_count += 1

        # Feature vector could look something like this:
        features = [
            feature_count,              # Total number of vulnerabilities
            integer_overflow,           # Count of integer overflow vulnerabilities
            unchecked_low_level_calls,  # Count of unchecked low-level calls
            warnings_count               # Total warnings found
        ]
    else:
        # Handle unexpected findings structure
        print("Unexpected findings structure.")
    
    return features

if __name__ == '__main__':
    app.run(debug=True)


# request to http://127.0.0.1:5000/analyze endpoint
# {
#   "contract_name": "VulnerableContract",
#   "source_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ncontract VulnerableContract {\n    address immutable owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function addFunds(uint256 _amount) public {\n        require(_amount > 0, \"Amount must be greater than 0.\");\n        // Function logic\n    }\n\n    function transferTo(address _to) public {\n        require(_to != address(0), \"Address cannot be zero.\");\n        (bool success,) = _to.call{value: msg.value}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function withdraw(uint256 _amount) public {\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Withdrawal failed.\");\n    }\n}",
#   "compiler_version": "0.8.6",
#   "analysis_tools": {
#     "mythril": true,
#     "slither": true,
#     "echidna": false
#   },
#   "additional_info": {
#     "user_id": "12345",
#     "request_id": "abc-xyz-123"
#   }
# }
# ####### Output #######
# {
#     "findings": [
#         {
#             "cwe": "CWE-190",
#             "description": "Integer overflow/underflow vulnerability detected.",
#             "mitre": "T1518",
#             "suggestion": "Use SafeMath library to prevent overflows and underflows.",
#             "vulnerability": "integer_overflow"
#         },
#         {
#             "cwe": "CWE-839",
#             "description": "Unchecked low-level call.",
#             "mitre": "T1519",
#             "suggestion": "Use require to check return value of low-level calls.",
#             "vulnerability": "unchecked_low_level_call"
#         }
#     ]
# }


### request to /predict endpoint
# {
#     "source_code": "pragma solidity ^0.8.0; contract Vulnerable { function withdraw(uint256 amount) public { msg.sender.call{value: amount}(""); } }"
# }
### Output ###
